Below is a **single, implementation-ready Jira** written in strict, machine-executable prose. It consolidates all findings (SEC-BE-0001..0005) into one story with deterministic tasks, file paths, commands, and acceptance criteria.

---

# Story: Harden Auth, Secrets, Dependencies, Containers, and Health Checks (SEC-BE-0001..0005)

**Type:** Story
**Priority:** Critical
**Scope:** Backend (.NET 8), Frontend (React/Vite), Dockerfiles, Compose, CI

## Goal (measurable)

* Expired JWTs are rejected (**401**) with ≤30s clock skew.
* No hardcoded secrets present in repo HEAD **or history**; all exposed secrets rotated.
* NPM vulnerabilities reduced to **0 CRITICAL/HIGH** (Trivy) and **0 audit high/critical** (npm audit).
* All containers run as **non-root** with minimal capabilities and `no-new-privileges`.
* All services have **working HEALTHCHECK**; compose start order gated on health.

## Constraints

* No breaking API/UX changes.
* Keep env var names and config structure unless noted.
* Secrets are never baked into frontend bundles.
* All changes reproducible via listed commands.

---

## Tasks (execute in order)

### 1) JWT lifetime validation (SEC-BE-0001)

**Edit:** `Backend/Program.cs` (or wherever `AddJwtBearer` is configured)

* Set:

  * `TokenValidationParameters.ValidateLifetime = true`
  * `TokenValidationParameters.RequireExpirationTime = true`
  * `TokenValidationParameters.ClockSkew = TimeSpan.FromSeconds(30)`

**Code (insert or update block):**

```csharp
builder.Services
  .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
  .AddJwtBearer(o =>
  {
      o.TokenValidationParameters = new TokenValidationParameters
      {
          ValidateIssuer = true,
          ValidIssuer = cfg.Jwt.Issuer,
          ValidateAudience = true,
          ValidAudience = cfg.Jwt.Audience,
          ValidateIssuerSigningKey = true,
          IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(cfg.Jwt.SigningKey)),
          ValidateLifetime = true,
          RequireExpirationTime = true,
          ClockSkew = TimeSpan.FromSeconds(30)
      };
  });
```

**Tests (add):**

* `Backend.Tests/Auth/JwtLifetimeTests.cs`

  * `ExpiredToken_Returns401()`
  * `WithinClockSkew_AcceptsOrRejectsAsConfigured()`
  * `RefreshFlow_RequiresRefreshForExpiredAccess()`

---

### 2) Secrets removal + rotation (SEC-BE-0002)

**Evidence paths:** `.env.dev.example`, `Frontend/dist/assets/index-*.js`, `Backend.Tools/bin/Debug/net8.0/login.json`, `Backend.Tools/bin/Debug/net8.0/refresh.json`

**Actions:**

1. **Rotate** any credential found in `reports/security/artifacts/gitleaks.json`:

   * JWT signing keys, SMTP/API tokens, Recaptcha, DB creds, etc.
2. **Purge from repo history**:

   * Install `git-filter-repo`.
   * Create `scripts/security/filter-secrets.txt` with globs:

     ```
     Frontend/dist/**
     Backend.Tools/bin/**/login.json
     Backend.Tools/bin/**/refresh.json
     *.pem
     *.pfx
     ```
   * Run:

     ```bash
     git filter-repo --path-glob Frontend/dist/** \
                     --path-glob Backend.Tools/bin/**/login.json \
                     --path-glob Backend.Tools/bin/**/refresh.json \
                     --invert-paths
     git push --force
     ```
3. **Harden .gitignore** (append if missing):

   * `Frontend/dist/`
   * `**/bin/`
   * `**/obj/`
   * `*.secret*`
   * `*.key`
   * `*.pfx`
   * `*.pem`
   * `.env`
4. Ensure only **templates** are committed:

   * Keep `.env.example` (no real secrets).
   * Delete any real `.env` files from repo.
5. **Prevent re-introduction**:

   * Add pre-commit hook: `.githooks/pre-commit`

     ```bash
     #!/usr/bin/env bash
     gitleaks protect --staged --redact || exit 1
     ```
   * In CI (GitHub Actions or similar), add step:

     ```bash
     gitleaks detect --redact --exit-code 1
     ```

---

### 3) NPM dependency vulnerabilities (SEC-BE-0003)

**Frontend directory:** `Frontend/`

**Actions:**

```bash
cd Frontend
npm ci
npm audit fix || true
npx npm-check-updates -u
npm install
npm audit --audit-level=high
```

* Add Renovate (repo root): `.github/renovate.json`

```json
{ "extends": ["config:recommended"], "rangeStrategy": "replace" }
```

* CI (repo root workflow): add Trivy FS step

```bash
trivy fs --exit-code 1 --severity HIGH,CRITICAL .
```

* Commit updated `package.json` and `package-lock.json`.

---

### 4) Containers run as root → run as non-root (SEC-BE-0004)

**Files:**

* `Backend/Dockerfile.dev` (and `Backend/Dockerfile` if exists)
* `Frontend/Dockerfile.dev` (and prod Dockerfile)
* `caddy/Dockerfile`
* `docker-compose.yml`

**Backend Dockerfile change (example):**

```dockerfile
# after publish/copy
RUN addgroup --system app && adduser --system --ingroup app --no-create-home --uid 10001 app
WORKDIR /app
COPY --chown=app:app --from=publish /app/publish ./
ENV DOTNET_EnableDiagnostics=0
USER 10001
```

**Frontend Dockerfile change (example):**

```dockerfile
RUN addgroup -S app && adduser -S app -G app -u 10001
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY --chown=10001:10001 . .
USER 10001
```

**Caddy Dockerfile (example):**

```dockerfile
# use official caddy, then drop root
RUN addgroup -S app && adduser -S app -G app -u 10001
USER 10001
```

(Ensure `/data` and `/config` permissions if used; otherwise use volumes owned by 10001.)

**Compose hardening (each service):** in `docker-compose.yml`

```yaml
services:
  backend:
    user: "10001:10001"
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs: ["/tmp"]
  frontend:
    user: "10001:10001"
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs: ["/tmp"]
  caddy:
    cap_drop: [ "ALL" ]
    cap_add: [ "NET_BIND_SERVICE" ]
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs: ["/tmp"]
```

Ensure writable paths (logs/uploads/certs) are mounted volumes with correct ownership.

---

### 5) Health checks for all containers (SEC-BE-0005)

**Backend (.NET):**

* Implement endpoints:

  * `/health` (liveness) and `/ready` (readiness) via `AspNetCore.HealthChecks`.
* Dockerfile:

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=20s --retries=3 \
  CMD curl -f http://127.0.0.1:8080/ready || exit 1
```

**Frontend (if served by node/static server):**

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s \
  CMD curl -f http://127.0.0.1:8081/ || exit 1
```

**Caddy:**

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=20s \
  CMD curl -f http://127.0.0.1:2019/metrics || curl -f http://127.0.0.1/ || exit 1
```

**docker-compose.yml (gate startup):**

```yaml
services:
  backend:
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://127.0.0.1:8080/ready || exit 1"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 20s
  caddy:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1/"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 20s

  # example dependency
  frontend:
    depends_on:
      backend:
        condition: service_healthy
```

---

## CI Additions (repo root)

Create workflow `.github/workflows/security.yml` with jobs:

1. **Gitleaks**

   ```bash
   gitleaks detect --redact --exit-code 1
   ```
2. **Trivy FS**

   ```bash
   trivy fs --exit-code 1 --severity HIGH,CRITICAL .
   ```
3. **Trivy Image** (optional post-build)
4. **Backend tests** (run JWT tests)
5. **ESLint/TypeCheck** for Frontend

---

## Acceptance Criteria (must all pass)

* **JWT:** Using an expired access token to call a protected endpoint returns **401**. Token within ±30s behaves per `ClockSkew`. Refresh flow only issues new access via refresh endpoint.
* **Secrets:** `gitleaks detect` returns **exit code 0** on HEAD and CI. Confirmed rotation for every key identified in prior report. No secrets present in `dist/`, `bin/`, or repo history for listed files.
* **Deps:** `npm audit --audit-level=high` returns **0 vulnerabilities**. `trivy fs` reports **0 HIGH/CRITICAL** for frontend.
* **Non-root:** `docker inspect` for each service shows **User=10001** (or non-0). Compose applies `no-new-privileges` and `read_only` where feasible.
* **Health:** `docker ps` shows `healthy` for backend and caddy. Compose `depends_on: condition: service_healthy` works; hitting service before readiness does not return 200.
* **Docs:** `reports/security/mitigations.md` added with: what was rotated, purge commands used, and verification screenshots/logs.

---

## Definition of Done

* All tasks committed with passing CI (security workflow included).
* AC checklist ticked in PR description with evidence.
* No regression in functional tests (auth flows, wizard, email).
* Rollback plan documented for each change that affects runtime (Docker user/permissions, healthchecks).

---

## Notes

* If `Frontend/dist/` or `bin/Debug` were ever committed, **history purge is mandatory** regardless of current HEAD cleanliness.
* For caddy cert storage, use volumes with correct ownership instead of granting root.

**End of Story.**
