1. High-Level Overview

This task is to implement the final step in the budget creation wizard. When the user clicks the final button, we will trigger a backend process that gathers all the data entered during the wizard, creates a complete budget aggregate, and saves it to the database. The frontend will show a loading state during this process and then navigate the user to their new dashboard upon successful completion.

2. Frontend (FE) Changes üé®

2a. FE Overview

The goal is to create a clean, decoupled finalization process. We will create a dedicated React hook to manage the API call and loading state. The main wizard component will use this hook, passing the necessary functions and state down to the final step component, which contains the submission button.

2b. FE File Changes

    src/api/Services/wizard/wizardService.ts (Modify)

        Change: Add a new function completeWizard(sessionId).

        Result: This function will be responsible for making the POST /wizard/{sessionId}/complete API call to the backend.

    src/hooks/wizard/useWizardFinalization.ts (Create)

        Change: Create a new hook that encapsulates the finalization logic. It will manage its own isFinalizing and error states, call wizardService.completeWizard, and handle success (redirect) or failure (error message).

        Result: This keeps the logic isolated, testable, and reusable, preventing the SetupWizard component from becoming bloated.

    src/components/organisms/overlays/wizard/SetupWizard.tsx (Modify)

        Change: Use the new useWizardFinalization hook to get the finalizeWizard function, isFinalizing state, and finalizationError state. Pass these down as props to the <StepBudgetFinal> component.

        Result: The main wizard component orchestrates the finalization step without containing the implementation details itself.

    src/components/organisms/overlays/wizard/steps/StepBudgetFinal5/Components/Pages/SubSteps/1_SubStepFinal/SubStepFinal.tsx (Modify)

        Change: Update the props to accept onFinalize, loading, and finalizationError. Connect the onClick event of the SubmitButton to the onFinalize prop and its isSubmitting state to the loading prop.

        Result: The button in the UI will now trigger the finalization flow and display a loading spinner and any potential errors.

3. Backend (BE) Changes ‚öôÔ∏è

3a. BE Overview

The goal is to create a secure and transactional endpoint to finalize the budget. We will follow the CQRS pattern by creating a command and a command handler. The handler will be responsible for fetching all wizard data for the session, mapping it into a Budget domain aggregate, and saving everything within a single database transaction to ensure data integrity.

3b. BE File Changes

    Backend/Presentation/Controllers/WizardController.cs (Modify)

        Change: Add a new [HttpPost("{sessionId}/complete")] endpoint named Complete(Guid sessionId).

        Result: This creates the public API endpoint that the frontend will call. It will dispatch the FinalizeBudgetCommand to MediatR.

    Backend/Application/Commands/FinalizeBudgetCommand.cs (Create)

        Change: Create a new record or class for the command, containing the Guid SessionId.

        Result: This defines the data contract for the finalization action, following the CQRS pattern.

    Backend/Application/Handlers/FinalizeBudgetCommandHandler.cs (Create)

        Change: Create a new handler for the FinalizeBudgetCommand. Its logic will:

            Fetch all WizardStep rows from the database for the given sessionId.

            Deserialize the JSON from the steps into a Budget aggregate (including incomes, expenses, etc.).

            Save the entire Budget aggregate to the database within a single DB transaction.

            (Optional) Publish a BudgetCreatedEvent to notify other parts of the system.

        Result: This provides a robust, transactional, and clearly defined service for the core business logic of creating a budget.
		
		
IMPORTANT: We are to only create the FE changes!		